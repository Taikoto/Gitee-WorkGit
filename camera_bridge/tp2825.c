/*
 * Copyright (C) 2012-2015 Freescale Semiconductor, Inc. All Rights Reserved.
 * Copyright 2018 NXP
 */

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/device.h>
#include <linux/i2c.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/of_device.h>
#include <linux/of_gpio.h>
#include <linux/pinctrl/consumer.h>
#include <linux/regulator/consumer.h>
#include <linux/v4l2-mediabus.h>
#include <media/v4l2-device.h>
#include <media/v4l2-ctrls.h>
#include <media/tp2825_config.h>


#define TP2825_IDENT		0x11

struct tp2825_datafmt {
	u32	code;
	enum v4l2_colorspace		colorspace;
};

struct tp2825 {
	struct v4l2_subdev		subdev;
	struct i2c_client *i2c_client;
	struct v4l2_pix_format pix;
	const struct tp2825_datafmt	*fmt;
	struct v4l2_captureparm streamcap;
	struct media_pad pad;
	bool on;
	bool mipi_csi;

	/* control settings */
	int brightness;
	int hue;
	int contrast;
	int saturation;
	int red;
	int green;
	int blue;
	int ae_mode;

	u32 mclk;
	u8 mclk_source;
	struct clk *sensor_clk;
	int csi;
	v4l2_std_id std_id;

	void (*io_init)(void);
};

/*!
 * Maintains the information on the current state of the sesor.
 */
static struct tp2825 tp2825_data;
static int rst_gpio;

/*! List of input video formats supported. The video formats is corresponding
 * with v4l2 id in video_fmt_t
 */
typedef enum {
	TP2825_NTSC = 0,	/*!< Locked on (M) NTSC video signal. */
	TP2825_PAL,		/*!< (B, G, H, I, N)PAL video signal. */
	TP2825_NOT_LOCKED,	/*!< Not locked on a signal. */
} video_fmt_idx;

/*! Number of video standards supported (including 'not locked' signal). */
#define TP2825_STD_MAX		(TP2825_PAL + 1)

/*! Video format structure. */
typedef struct {
	int v4l2_id;		/*!< Video for linux ID. */
	char name[16];		/*!< Name (e.g., "NTSC", "PAL", etc.) */
	u16 raw_width;		/*!< Raw width. */
	u16 raw_height;		/*!< Raw height. */
	u16 active_width;	/*!< Active width. */
	u16 active_height;	/*!< Active height. */
	int frame_rate;		/*!< Frame rate. */
} video_fmt_t;

/*! Description of video formats supported.
 *
 *  PAL: raw=720x625, active=720x576.
 *  NTSC: raw=720x525, active=720x480.
 */
static video_fmt_t video_fmts[] = {
	{			/*! NTSC */
	 .v4l2_id = V4L2_STD_NTSC,	 	
	 .name = "NTSC",
	 
#if TP2825_720X480
	 .raw_width = 720,	/* SENS_FRM_WIDTH */
	 .raw_height = 525,	/* SENS_FRM_HEIGHT */
	 .active_width = 720,	/* ACT_FRM_WIDTH plus 1 */
	 .active_height = 480,	/* ACT_FRM_WIDTH plus 1 */
	 .frame_rate = 30,	 
#endif

#if (TP2825_1280X720 || TP2825_1280X720_V1)
	.raw_width = 1280,//1980,
	.raw_height = 720,//720,
	.active_width = 1280,
	.active_height = 720,
#endif

#if TP2825_960X480
	.raw_width = 960,
	.raw_height = 480,
	.active_width = 960,
	.active_height = 480,
#endif

	
#if TP2825_50HZ
	.frame_rate = 50,
#endif

#if TP2825_25HZ	
	.frame_rate = 25,
#endif

#if (TP2825_30HZ )
	.frame_rate = 30,
#endif

#if (TP2825_60HZ )
	.frame_rate = 60,
#endif
	 },
	 
	{			/*! (B, G, H, I, N) PAL */
	 .v4l2_id = V4L2_STD_PAL,
	 .name = "PAL", 
#if TP2825_720X480	 
	 .raw_width = 720,
	 .raw_height = 625,
	 .active_width = 720,
	 .active_height = 576,
	 .frame_rate = 25,
#endif

#if (TP2825_1280X720 || TP2825_1280X720_V1)
	.raw_width = 1280,//1980,
	.raw_height = 720,//720,
	.active_width = 1280,
	.active_height = 720,
#endif

#if TP2825_960X480
	.raw_width = 960,
	.raw_height = 480,
	.active_width = 960,
	.active_height = 480,
#endif
	
#if TP2825_50HZ
	.frame_rate = 50,
#endif

#if TP2825_25HZ	
	.frame_rate = 25,
#endif

#if (TP2825_30HZ )
	.frame_rate = 30,
#endif

#if (TP2825_60HZ )
	.frame_rate = 60,
#endif

	 },
	{			/*! Unlocked standard */
#if 0	
	 .v4l2_id = V4L2_STD_ALL,
	 .name = "Autodetect",
	 .raw_width = 720,
	 .raw_height = 525,
	 .active_width = 720,
	 .active_height = 480,
	 .frame_rate = 30,
#else//lqc add test

	.v4l2_id = V4L2_STD_ALL,
	.name = "Autodetect",
	.raw_width = 1280,
	.raw_height = 720,
	.active_width = 1280,
	.active_height = 720,
	.frame_rate = 30,
#endif

	 },
};

/*!* Standard index of TP2825. */
static video_fmt_idx video_idx = TP2825_NTSC;
//static video_fmt_idx video_idx = TP2825_NTSC;


static int tp2825_probe(struct i2c_client *adapter,
				const struct i2c_device_id *device_id);
static int tp2825_remove(struct i2c_client *client);

static const struct i2c_device_id tp2825_id[] = {
	{"tp2825", 0},
	{},
};

MODULE_DEVICE_TABLE(i2c, tp2825_id);

static struct i2c_driver tp2825_i2c_driver = {
	.driver = {
		  .owner = THIS_MODULE,
		  .name  = "tp2825",
		  },
	.probe  = tp2825_probe,
	.remove = tp2825_remove,
	.id_table = tp2825_id,
};


static struct tp2825 *to_tp2825(const struct i2c_client *client)
{
	return container_of(i2c_get_clientdata(client), struct tp2825, subdev);
}

static inline void tp2825_reset(void)
{
	gpio_set_value_cansleep(rst_gpio, 0);
	msleep(50);
	gpio_set_value_cansleep(rst_gpio, 1);
	msleep(50);
}

static int tp2825_write_reg(u8 reg, u8 val)
{
	s32 ret;

	ret = i2c_smbus_write_byte_data(tp2825_data.i2c_client, reg, val);
	if (ret < 0) {
		pr_err("%s:write reg error:reg=0x%2x,val=0x%2x\n", __func__,
			reg, val);
		return -1;
	}
	return 0;
}

static inline int tp2825_read(u8 reg)
{
	int val;

	val = i2c_smbus_read_byte_data(tp2825_data.i2c_client, reg);
	if (val < 0) {
		pr_err("%s:read reg error: reg=x%2x\n", __func__, reg);
		return -1;
	}
	return val;
}

static int tp2825_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)
{
	*norm = (video_idx == TP2825_PAL) ? V4L2_STD_PAL : V4L2_STD_NTSC;
	if (*norm != tp2825_data.std_id) 
	{
		tp2825_data.std_id = *norm;
		tp2825_data.pix.width = video_fmts[video_idx].raw_width;
		tp2825_data.pix.height = video_fmts[video_idx].raw_height;		
	}
	//*norm = V4L2_STD_ALL;
	
	return 0;
}

static int tp2825_link_setup(struct media_entity *entity,
			   const struct media_pad *local,
			   const struct media_pad *remote, u32 flags)
{
	return 0;
}

static int tp2825_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct tp2825 *sensor = to_tp2825(client);
	struct v4l2_captureparm *cparm = &a->parm.capture;
	int ret = 0;

	switch (a->type) {
	/* This is the only case currently handled. */
	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
		memset(a, 0, sizeof(*a));
		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
		cparm->capability = sensor->streamcap.capability;
		cparm->timeperframe = sensor->streamcap.timeperframe;
		cparm->capturemode = sensor->streamcap.capturemode;
		ret = 0;
		break;

	/* These are all the possible cases. */
	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
	case V4L2_BUF_TYPE_VBI_CAPTURE:
	case V4L2_BUF_TYPE_VBI_OUTPUT:
	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
		ret = -EINVAL;
		break;

	default:
		pr_debug("   type is unknown - %d\n", a->type);
		ret = -EINVAL;
		break;
	}

	return ret;
}

static int tp2825_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
{
	return 0;
}

static int tp2825_s_stream(struct v4l2_subdev *sd, int enable)
{
	return 0;
}

static int tp2825_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
{
//	((struct v4l2_dbg_chip_ident *)id)->match.type = V4L2_CHIP_MATCH_SUBDEV;//V4L2_CHIP_MATCH_I2C_DRIVER;

	strcpy(chip->match.name, "tp2825");

	return 0;
}

static int tp2825_s_power(struct v4l2_subdev *sd, int on)
{
	return 0;
}

static int tp2825_enum_framesizes(struct v4l2_subdev *sd,
			       struct v4l2_subdev_pad_config *cfg,
			       struct v4l2_subdev_frame_size_enum *fse)
{
	if (fse->index >= 1)
		return -EINVAL;

	fse->max_width = fse->min_width = video_fmts[video_idx].active_width;
	fse->max_height = fse->min_height = video_fmts[video_idx].active_height;

	return 0;
}

static int tp2825_set_fmt(struct v4l2_subdev *sd,
			  struct v4l2_subdev_pad_config *cfg,
			  struct v4l2_subdev_format *format)
{
	return 0;
}

static int tp2825_get_fmt(struct v4l2_subdev *sd,
			  struct v4l2_subdev_pad_config *cfg,
			  struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;

	if (format->pad)
		return -EINVAL;

	memset(mf, 0, sizeof(struct v4l2_mbus_framefmt));

	mf->code = MEDIA_BUS_FMT_VYUY8_2X8;
	//mf->width = 720;
	
#if TP2825_1280X720	
	mf->width = 1280;
	mf->field = V4L2_FIELD_SEQ_TB;//V4L2_FIELD_NONE;//V4L2_FIELD_SEQ_TB;
	mf->colorspace = V4L2_COLORSPACE_SMPTE240M;//V4L2_COLORSPACE_SMPTE170M;//V4L2_COLORSPACE_SMPTE240M;//V4L2_COLORSPACE_RAW;
	//mf->colorspace = V4L2_COLORSPACE_SMPTE170M;//V4L2_COLORSPACE_SMPTE170M;//V4L2_COLORSPACE_SMPTE240M;//V4L2_COLORSPACE_RAW;
#endif

#if TP2825_960X480
	mf->width = 960;
	mf->field = V4L2_FIELD_INTERLACED;
	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
#endif
	
#if TP2825_720X480
		mf->width = 720;
		mf->field = V4L2_FIELD_INTERLACED;
		mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
#endif

	mf->height = video_fmts[video_idx].active_height;
	printk("tp2825_get_fmt mf->width=%d mf->field=%d\n",mf->width,mf->field);
	return 0;
}

static const struct v4l2_subdev_video_ops tp2825_video_ops = {
	.g_std = tp2825_g_std,
	.g_parm = tp2825_g_parm,
	.s_parm = tp2825_s_parm,
	.s_stream = tp2825_s_stream,
};

static const struct v4l2_subdev_core_ops tp2825_core_ops = {
	.g_chip_ident = tp2825_chip_ident,
	.s_power = tp2825_s_power,
};

static const struct v4l2_subdev_pad_ops tp2825_pad_ops = {
	.enum_frame_size = tp2825_enum_framesizes,
	.set_fmt = tp2825_set_fmt,
	.get_fmt = tp2825_get_fmt,
};

static const struct v4l2_subdev_ops tp2825_ops = {
	.core = &tp2825_core_ops,
	.video = &tp2825_video_ops,
	.pad = &tp2825_pad_ops,
};

static const struct media_entity_operations tp2825_sd_media_ops = {
	.link_setup = tp2825_link_setup,
};

#if TP2825_1280X720_V1

static unsigned char tp2825_init_regs[] = 
{	
#if 1 //1280X720 25HZ lqc ok,hu,v1.0

	0xFF, 0x00, //; Page 0
	0x00, 0x11,
	0x01, 0x7E,
	0x02, 0xCA,	
	0x03, 0x1d,
	0x04, 0x00,
	0x05, 0x00,
	0x06, 0x32,
	0x07, 0xC0,
	0x08, 0x00,
	0x09, 0x24,
	0x0A, 0x48,
	0x0B, 0xC0,
	0x0C, 0x43,//0x0C, 0x53,
	0x0D, 0x10,
	0x0E, 0x00,
	0x0F, 0x00,
	0x10, 0x00,
	0x11, 0x40,
	0x12, 0x40,
	0x13, 0x00,
	0x14, 0x00,
	0x15, 0x13,
	0x16, 0x16,
	0x17, 0x00,
	0x18, 0x19,
	0x19, 0xD0,
	0x1A, 0x25,
	0x1B, 0x00,
	0x1C, 0x0f,//0x1C, 0x07,
	0x1D, 0x78,//0x1D, 0xBC,
	0x1E, 0x80,
	0x1F, 0x80,
	0x20, 0x60,
	0x21, 0x86,
	0x22, 0x38,
	0x23, 0x3C,
	0x24, 0x56,
	0x25, 0xFF,
	0x26, 0x02,
	0x27, 0x2D,
	0x28, 0x00,
	0x29, 0x48,
	0x2A, 0x30,
	0x2B, 0x70,
	0x2C, 0x0A,
	0x2D, 0x30,
	0x2E, 0x70,
	0x2F, 0x00,
	0x30, 0x48,
	0x31, 0xBB,
	0x32, 0x2E,
	0x33, 0x90,
	0x34, 0x00,
	0x35, 0x05,//0x35, 0x25,
	0x36, 0xDC,
	0x37, 0x00,
	0x38, 0x40,
	0x39, 0x8c,//0x39, 0x88,
	0x3A, 0x00,
	0x3B, 0x03,
	0x3C, 0x00,
	0x3D, 0x60,
	0x3E, 0x00,
	0x3F, 0x00,
	0x40, 0x00,
	0x41, 0x00,
	0x42, 0x00,
	0x43, 0x12,
	0x44, 0x07,
	0x45, 0x49,
	0x46, 0x00,
	0x47, 0x00,
	0x48, 0x00,
	0x49, 0x00,
	0x4A, 0x00,
	0x4B, 0x00,
	0x4C, 0x03,
	0x4D, 0x03,
	0x4E, 0x03,//0x4E, 0x17,
	0x4F, 0x00,
	0x50, 0x00,
	0x51, 0x00,
	0x52, 0x00,
	0x53, 0x00,
	0x54, 0x00,
	0x55, 0x00,
	0x56, 0x00,
	0x57, 0x00,
	0x58, 0x00,
	0x59, 0x00,
	0x5A, 0x00,
	0x5B, 0x00,
	0x5C, 0x00,
	0x5D, 0x00,
	0x5E, 0x00,
	0x5F, 0x00,
	0x60, 0x00,
	0x61, 0x00,
	0x62, 0x00,
	0x63, 0x00,
	0x64, 0x00,
	0x65, 0x00,
	0x66, 0x00,
	0x67, 0x00,
	0x68, 0x00,
	0x69, 0x00,
	0x6A, 0x00,
	0x6B, 0x00,
	0x6C, 0x00,
	0x6D, 0x00,
	0x6E, 0x00,
	0x6F, 0x00,
	0x70, 0x00,
	0x71, 0x00,
	0x72, 0x00,
	0x73, 0x00,
	0x74, 0x00,
	0x75, 0x00,
	0x76, 0x00,
	0x77, 0x00,
	0x78, 0x00,
	0x79, 0x00,
	0x7A, 0x00,
	0x7B, 0x00,
	0x7C, 0x00,
	0x7D, 0x00,
	0x7E, 0x01,
	0x7F, 0x00,
	0x80, 0x00,
	0x81, 0x00,
	0x82, 0x00,
	0x83, 0x00,
	0x84, 0x00,
	0x85, 0x00,
	0x86, 0x00,
	0x87, 0x00,
	0x88, 0x00,
	0x89, 0x00,
	0x8A, 0x00,
	0x8B, 0xFF,
	0x8C, 0xFF,
	0x8D, 0xFF,
	0x8E, 0xFF,
	0x8F, 0xFF,
	0x90, 0xFF,
	0x91, 0xFF,
	0x92, 0xFF,
	0x93, 0xFF,
	0x94, 0xFF,
	0x95, 0x00,
	0x96, 0x00,
	0x97, 0x00,
	0x98, 0x00,
	0x99, 0x00,
	0x9A, 0x00,
	0x9B, 0x00,
	0x9C, 0x00,
	0x9D, 0x00,
	0x9E, 0x00,
	0x9F, 0x00,
	0xA0, 0x00,
	0xA1, 0x00,
	0xA2, 0x00,
	0xA3, 0x00,
	0xA4, 0x00,
	0xA5, 0x00,
	0xA6, 0x00,
	0xA7, 0x00,
	0xA8, 0x00,
	0xA9, 0x00,
	0xAA, 0x00,
	0xAB, 0x00,
	0xAC, 0x00,
	0xAD, 0x00,
	0xAE, 0x00,
	0xAF, 0x00,
	0xB0, 0x00,
	0xB1, 0x00,
	0xB2, 0x00,
	0xB3, 0xFA,
	0xB4, 0x00,
	0xB5, 0x00,
	0xB6, 0x00,
	0xB7, 0x00,
	0xB8, 0x00,
	0xB9, 0x01,
	0xBA, 0x00,
	0xBB, 0x00,
	0xBC, 0x03,
	0xBD, 0x00,
	0xBE, 0x00,
	0xBF, 0x00,
	0xC0, 0x00,
	0xC1, 0x00,
	0xC2, 0x0B,
	0xC3, 0x0C,
	0xC4, 0x00,
	0xC5, 0x00,
	0xC6, 0x1F,
	0xC7, 0x78,
	0xC8, 0x21,
	0xC9, 0x00,
	0xCA, 0x00,
	0xCB, 0x07,
	0xCC, 0x08,
	0xCD, 0x00,
	0xCE, 0x00,
	0xCF, 0x04,
	0xD0, 0x00,
	0xD1, 0x00,
	0xD2, 0x60,
	0xD3, 0x10,
	0xD4, 0x06,
	0xD5, 0xBE,
	0xD6, 0x39,
	0xD7, 0x27,
	0xD8, 0x00,
	0xD9, 0x00,
	0xDA, 0x00,
	0xDB, 0x00,
	0xDC, 0x00,
	0xDD, 0x00,
	0xDE, 0x00,
	0xDF, 0x00,
	0xE0, 0x00,
	0xE1, 0x00,
	0xE2, 0x00,
	0xE3, 0x00,
	0xE4, 0x00,
	0xE5, 0x00,
	0xE6, 0x00,
	0xE7, 0x00,
	0xE8, 0x00,
	0xE9, 0x00,
	0xEA, 0x00,
	0xEB, 0x00,
	0xEC, 0x00,
	0xED, 0x00,
	0xEE, 0x00,
	0xEF, 0x00,
	0xF0, 0x00,
	0xF1, 0x00,
	0xF2, 0x00,
	0xF3, 0x00,
	0xF4, 0x00,
	0xF5, 0x00,
	0xF6, 0x00,
	0xF7, 0x00,
	0xF8, 0x00,
	0xF9, 0x00,
	0xFA, 0x00,
	0xFB, 0x00,
	0xFC, 0xC0,
	0xFD, 0x00,
	0xFE, 0x28,

#else
	//1280X720 25HZ lqc error,li
	0xFF, 0x00,  //; Page 0
	0x00, 0x11,
	0x01, 0x7E,
	0x02, 0xCA,
	0x03, 0x05,
	0x04, 0x00,
	0x05, 0x00,
	0x06, 0x32,
	0x07, 0xC0,
	0x08, 0x00,
	0x09, 0x24,
	0x0A, 0x48,
	0x0B, 0xC0,
	0x0C, 0x43,
	0x0D, 0x10, 
	0x0E, 0x00,
	0x0F, 0x00,
	0x10, 0x00,
	0x11, 0x40,
	0x12, 0x40,
	0x13, 0x00,
	0x14, 0x00,
	0x15, 0x13,
	0x16, 0x16,
	0x17, 0x00,
	0x18, 0x19,
	0x19, 0xD0,
	0x1A, 0x25,
	0x1B, 0x00,
	0x1C, 0x0F,
	0x1D, 0x78,
	0x1E, 0x80,
	0x1F, 0x80,
	0x20, 0x60,
	0x21, 0x86,
	0x22, 0x38,
	0x23, 0x3C,
	0x24, 0x56,
	0x25, 0xFF,
	0x26, 0x02,
	0x27, 0x2D,
	0x28, 0x00,
	0x29, 0x48,
	0x2A, 0x30,
	0x2B, 0x4A,
	0x2C, 0x0A,
	0x2D, 0x30,
	0x2E, 0x70,
	0x2F, 0x00,
	0x30, 0x48,
	0x31, 0xBB,
	0x32, 0x2E,
	0x33, 0x90,
	0x34, 0x00,
	0x35, 0x05,
	0x36, 0xDC,
	0x37, 0x00,
	0x38, 0x40,
	0x39, 0x8C,
	0x3A, 0x00,
	0x3B, 0x03,
	0x3C, 0x00,
	0x3D, 0x60,
	0x3E, 0x00,
	0x3F, 0x00,
	0x40, 0x00,
	0x41, 0x00,
	0x42, 0x00,
	0x43, 0x12,
	0x44, 0x07,
	0x45, 0x49,
	0x46, 0x00,
	0x47, 0x00,
	0x48, 0x00,
	0x49, 0x00,
	0x4A, 0x00,
	0x4B, 0x00,
	0x4C, 0x00,
	0x4D, 0x03,
	0x4E, 0x03,
	0x4F, 0x00,
	0x50, 0x00,
	0x51, 0x00,
	0x52, 0x00,
	0x53, 0x00,
	0x54, 0x00,
	0x55, 0x00,
	0x56, 0x00,
	0x57, 0x00,
	0x58, 0x00,
	0x59, 0x00,
	0x5A, 0x00,
	0x5B, 0x00,
	0x5C, 0x00,
	0x5D, 0x00,
	0x5E, 0x00,
	0x5F, 0x00,
	0x60, 0x00,
	0x61, 0x00,
	0x62, 0x00,
	0x63, 0x00,
	0x64, 0x00,
	0x65, 0x00,
	0x66, 0x00,
	0x67, 0x00,
	0x68, 0x00,
	0x69, 0x00,
	0x6A, 0x00,
	0x6B, 0x00,
	0x6C, 0x00,
	0x6D, 0x00,
	0x6E, 0x00,
	0x6F, 0x00,
	0x70, 0x00,
	0x71, 0x00,
	0x72, 0x00,
	0x73, 0x00,
	0x74, 0x00,
	0x75, 0x00,
	0x76, 0x00,
	0x77, 0x00,
	0x78, 0x00,
	0x79, 0x00,
	0x7A, 0x00,
	0x7B, 0x00,
	0x7C, 0x00,
	0x7D, 0x00,
	0x7E, 0x01,
	0x7F, 0x00,
	0x80, 0x00,
	0x81, 0x00,
	0x82, 0x00,
	0x83, 0x00,
	0x84, 0x00,
	0x85, 0x00,
	0x86, 0x00,
	0x87, 0x00,
	0x88, 0x00,
	0x89, 0x00,
	0x8A, 0x00,
	0x8B, 0xFF,
	0x8C, 0xFF,
	0x8D, 0xFF,
	0x8E, 0xFF,
	0x8F, 0xFF,
	0x90, 0xFF,
	0x91, 0xFF,
	0x92, 0xFF,
	0x93, 0xFF,
	0x94, 0xFF,
	0x95, 0x00,
	0x96, 0x00,
	0x97, 0x00,
	0x98, 0x00,
	0x99, 0x00,
	0x9A, 0x00,
	0x9B, 0x00,
	0x9C, 0x00,
	0x9D, 0x00,
	0x9E, 0x00,
	0x9F, 0x00,
	0xA0, 0x00,
	0xA1, 0x00,
	0xA2, 0x00,
	0xA3, 0x00,
	0xA4, 0x00,
	0xA5, 0x00,
	0xA6, 0x00,
	0xA7, 0x00,
	0xA8, 0x00,
	0xA9, 0x00,
	0xAA, 0x00,
	0xAB, 0x00,
	0xAC, 0x00,
	0xAD, 0x00,
	0xAE, 0x00,
	0xAF, 0x00,
	0xB0, 0x00,
	0xB1, 0x00,
	0xB2, 0x00,
	0xB3, 0xFA,
	0xB4, 0x00,
	0xB5, 0x00,
	0xB6, 0x00,
	0xB7, 0x00,
	0xB8, 0x00,
	0xB9, 0x01,
	0xBA, 0x00,
	0xBB, 0x00,
	0xBC, 0x03,
	0xBD, 0x00,
	0xBE, 0x00,
	0xBF, 0x00,
	0xC0, 0x00,
	0xC1, 0x00,
	0xC2, 0x0B,
	0xC3, 0x0C,
	0xC4, 0x00,
	0xC5, 0x00,
	0xC6, 0x1F,
	0xC7, 0x78,
	0xC8, 0x21,
	0xC9, 0x00,
	0xCA, 0x00,
	0xCB, 0x07,
	0xCC, 0x08,
	0xCD, 0x00,
	0xCE, 0x00,
	0xCF, 0x04,
	0xD0, 0x00,
	0xD1, 0x00,
	0xD2, 0x60,
	0xD3, 0x10,
	0xD4, 0x06,
	0xD5, 0xBE,
	0xD6, 0x39,
	0xD7, 0x27,
	0xD8, 0x00,
	0xD9, 0x00,
	0xDA, 0x00,
	0xDB, 0x00,
	0xDC, 0x00,
	0xDD, 0x00,
	0xDE, 0x00,
	0xDF, 0x00,
	0xE0, 0x00,
	0xE1, 0x00,
	0xE2, 0x00,
	0xE3, 0x00,
	0xE4, 0x00,
	0xE5, 0x00,
	0xE6, 0x00,
	0xE7, 0x00,
	0xE8, 0x00,
	0xE9, 0x00,
	0xEA, 0x00,
	0xEB, 0x00,
	0xEC, 0x00,
	0xED, 0x00,
	0xEE, 0x00,
	0xEF, 0x00,
	0xF0, 0x00,
	0xF1, 0x00,
	0xF2, 0x00,
	0xF3, 0x00,
	0xF4, 0x00,
	0xF5, 0x00,
	0xF6, 0x00,
	0xF7, 0x00,
	0xF8, 0x00,
	0xF9, 0x00,
	0xFA, 0x00,
	0xFB, 0x00,
	0xFC, 0xC0,
	0xFD, 0x00,
	0xFE, 0x28,
	0xFF, 0x25,
#endif	
};
#endif


#if TP2825_960X480 ////960X480,60hz,30fps,ok
static unsigned char tp2825_init_regs[] = 
{
	0xFF, 0x00,  //; Page 0
	0x00, 0x11,
	0x01, 0x78,
	0x02, 0xCF,
	0x03, 0x0E,
	0x04, 0x00,
	0x05, 0x00,
	0x06, 0x32,
	0x07, 0xC0,
	0x08, 0x00,
	0x09, 0x24,
	0x0A, 0x48,
	0x0B, 0xC0,
	0x0C, 0x53,
	0x0D, 0x10,
	0x0E, 0x00,
	0x0F, 0x00,
	0x10, 0x00,
	0x11, 0x40,
	0x12, 0x40,
	0x13, 0x00,
	0x14, 0x00,	
	
	0x15, 0x13,
	0x16, 0x4E,
	0x17, 0x80, //org: 0xBC,
	
	0x18, 0x15,
	0x19, 0xF0,
	0x1A, 0x07,
	0x1B, 0x00,
	0x1C, 0x09,
	0x1D, 0x38,
	0x1E, 0x80,
	0x1F, 0x80,
	0x20, 0xA0,
	0x21, 0x86,
	0x22, 0x38,
	0x23, 0x3C,
	0x24, 0x56,
	0x25, 0xFF,
	0x26, 0x12,
	0x27, 0x2D,
	0x28, 0x00,
	0x29, 0x48,
	0x2A, 0x30,
	0x2B, 0x70,
	0x2C, 0x0A,
	0x2D, 0x68,
	0x2E, 0x5E,
	0x2F, 0x00,
	0x30, 0x62,
	0x31, 0xBB,
	0x32, 0x96,
	0x33, 0xC0,
	0x34, 0x00,
	0x35, 0x65,
	0x36, 0xDC,
	0x37, 0x00,

	//0x38, 0x40,
	0x38, 0x4e,
	
	0x39, 0x84,
	0x3A, 0x00,
	0x3B, 0x03,
	0x3C, 0x00,

	
	//0x3D, 0x60,
	//0x3E, 0x00,	
	0x3D, 0x40,	
	0x3E, 0x80,
	
	
	0x3F, 0x00,
	0x40, 0x00,
	
	//0x41, 0x00,
	0x41, 0x05,
	
	0x42, 0x00,
	0x43, 0x12,
	0x44, 0x07,
	0x45, 0x49,
	0x46, 0x00,
	0x47, 0x00,
	0x48, 0x00,
	0x49, 0x00,
	0x4A, 0x00,
	0x4B, 0x00,
	0x4C, 0x03,
	0x4D, 0x03,
	0x4E, 0x37,
	0x4F, 0x00,
	0x50, 0x00,
	0x51, 0x00,
	0x52, 0x00,
	0x53, 0x00,
	0x54, 0x00,
	0x55, 0x00,
	0x56, 0x00,
	0x57, 0x00,
	0x58, 0x00,
	0x59, 0x00,
	0x5A, 0x00,
	0x5B, 0x00,
	0x5C, 0x00,
	0x5D, 0x00,
	0x5E, 0x00,
	0x5F, 0x00,
	0x60, 0x00,
	0x61, 0x00,
	0x62, 0x00,
	0x63, 0x00,
	0x64, 0x00,
	0x65, 0x00,
	0x66, 0x00,
	0x67, 0x00,
	0x68, 0x00,
	0x69, 0x00,
	0x6A, 0x00,
	0x6B, 0x00,
	0x6C, 0x00,
	0x6D, 0x00,
	0x6E, 0x00,
	0x6F, 0x00,
	0x70, 0x00,
	0x71, 0x00,
	0x72, 0x00,
	0x73, 0x00,
	0x74, 0x00,
	0x75, 0x00,
	0x76, 0x00,
	0x77, 0x00,
	0x78, 0x00,
	0x79, 0x00,
	0x7A, 0x00,
	0x7B, 0x00,
	0x7C, 0x00,
	0x7D, 0x00,
	0x7E, 0x01,
	0x7F, 0x00,
	0x80, 0x00,
	0x81, 0x00,
	0x82, 0x00,
	0x83, 0x00,
	0x84, 0x00,
	0x85, 0x00,
	0x86, 0x00,
	0x87, 0x00,
	0x88, 0x00,
	0x89, 0x00,
	0x8A, 0x00,
	0x8B, 0x80,
	0x8C, 0x00,
	0x8D, 0x00,
	0x8E, 0x00,
	0x8F, 0x00,
	0x90, 0x80,
	0x91, 0x00,
	0x92, 0x00,
	0x93, 0x00,
	0x94, 0x00,
	0x95, 0x00,
	0x96, 0x00,
	0x97, 0x00,
	0x98, 0x00,
	0x99, 0x00,
	0x9A, 0x00,
	0x9B, 0x00,
	0x9C, 0x00,
	0x9D, 0x00,
	0x9E, 0x00,
	0x9F, 0x00,
	0xA0, 0x00,
	0xA1, 0x00,
	0xA2, 0x00,
	0xA3, 0x00,
	0xA4, 0x00,
	0xA5, 0x00,
	0xA6, 0x00,
	0xA7, 0x00,
	0xA8, 0x00,
	0xA9, 0x00,
	0xAA, 0x00,
	0xAB, 0x00,
	0xAC, 0x00,
	0xAD, 0x00,
	0xAE, 0x00,
	0xAF, 0x00,
	0xB0, 0x00,
	0xB1, 0x00,
	0xB2, 0x00,
	0xB3, 0xFA,
	0xB4, 0x00,
	0xB5, 0x00,
	0xB6, 0x00,
	0xB7, 0x00,
	0xB8, 0x00,
	0xB9, 0x01,
	0xBA, 0x00,
	0xBB, 0x00,
	0xBC, 0x03,
	0xBD, 0x00,
	0xBE, 0x00,
	0xBF, 0x00,
	0xC0, 0x00,
	0xC1, 0x00,
	0xC2, 0x0B,
	0xC3, 0x0C,
	0xC4, 0x00,
	0xC5, 0x00,
	0xC6, 0x1F,
	0xC7, 0x78,
	0xC8, 0x21,
	0xC9, 0x00,
	0xCA, 0x00,
	0xCB, 0x07,
	0xCC, 0x08,
	0xCD, 0x00,
	0xCE, 0x00,
	0xCF, 0x04,
	0xD0, 0x00,
	0xD1, 0x00,
	0xD2, 0x60,
	0xD3, 0x10,
	0xD4, 0x06,
	0xD5, 0xBE,
	0xD6, 0x39,
	0xD7, 0x27,
	0xD8, 0x00,
	0xD9, 0x00,
	0xDA, 0x00,
	0xDB, 0x00,
	0xDC, 0x00,
	0xDD, 0x00,
	0xDE, 0x00,
	0xDF, 0x00,
	0xE0, 0x00,
	0xE1, 0x00,
	0xE2, 0x00,
	0xE3, 0x00,
	0xE4, 0x00,
	0xE5, 0x00,
	0xE6, 0x00,
	0xE7, 0x00,
	0xE8, 0x00,
	0xE9, 0x00,
	0xEA, 0x00,
	0xEB, 0x00,
	0xEC, 0x00,
	0xED, 0x00,
	0xEE, 0x00,
	0xEF, 0x00,
	0xF0, 0x00,
	0xF1, 0x00,
	0xF2, 0x00,
	0xF3, 0x00,
	0xF4, 0x00,
	0xF5, 0x00,
	0xF6, 0x00,
	0xF7, 0x00,
	0xF8, 0x00,
	0xF9, 0x00,
	0xFA, 0x00,
	0xFB, 0x00,
	0xFC, 0xC0,
	0xFD, 0x00,
	0xFE, 0x28,

};
#endif



#if TP2825_1280X720

static unsigned char tp2825_init_regs[] = //NTFS
{

#if TP2825_50HZ 
	0xFF, 0x00, //; Page 0
	0x00, 0x11,
	0x01, 0x7E,
	0x02, 0xCA,
	0x03, 0x01,
	0x04, 0x00,
	0x05, 0x00,
	0x06, 0x32,
	0x07, 0xC0,
	0x08, 0x00,
	0x09, 0x24,
	0x0A, 0x48,
	0x0B, 0xC0,
	0x0C, 0x43,
	0x0D, 0x10,
	0x0E, 0x00,
	0x0F, 0x00,
	0x10, 0x00,
	0x11, 0x40,
	0x12, 0x40,
	0x13, 0x00,
	0x14, 0x00,
	0x15, 0x13,
	0x16, 0x16,
	0x17, 0x00,
	0x18, 0x19,
	0x19, 0xD0,
	0x1A, 0x25,
	0x1B, 0x00,
	0x1C, 0x07,
	0x1D, 0xBC,
	0x1E, 0x80,
	0x1F, 0x80,
	0x20, 0x60,
	0x21, 0x86,
	0x22, 0x38,
	0x23, 0x3C,
	0x24, 0x56,
	0x25, 0xFF,
	0x26, 0x02,
	0x27, 0x2D,
	0x28, 0x00,
	0x29, 0x48,
	0x2A, 0x30,
	0x2B, 0x4A,
	0x2C, 0x0A,
	0x2D, 0x30,
	0x2E, 0x70,
	0x2F, 0x00,
	0x30, 0x48,
	0x31, 0xBB,
	0x32, 0x2E,
	0x33, 0x90,
	0x34, 0x00,
	0x35, 0x05,
	0x36, 0xDC,
	0x37, 0x00,
	
	//0x38, 0x40,	
	0x38, 0x4e,

	0x39, 0x8C,
	0x3A, 0x00,
	0x3B, 0x03,
	0x3C, 0x00,
	
	//0x3D, 0x60,
	//0x3E, 0x00,

	0x3D, 0x40,
	0x3E, 0x80,


	0x3F, 0x00,
	0x40, 0x00,


	//0x41, 0x00,
	0x41, 0x05,

	0x42, 0x00,
	0x43, 0x12,
	0x44, 0x07,
	0x45, 0x49,
	0x46, 0x00,
	0x47, 0x00,
	0x48, 0x00,
	0x49, 0x00,
	0x4A, 0x00,
	0x4B, 0x00,
	0x4C, 0x03,
	0x4D, 0x03,
	0x4E, 0x03,
	0x4F, 0x00,
	0x50, 0x00,
	0x51, 0x00,
	0x52, 0x00,
	0x53, 0x00,
	0x54, 0x00,
	0x55, 0x00,
	0x56, 0x00,
	0x57, 0x00,
	0x58, 0x00,
	0x59, 0x00,
	0x5A, 0x00,
	0x5B, 0x00,
	0x5C, 0x00,
	0x5D, 0x00,
	0x5E, 0x00,
	0x5F, 0x00,
	0x60, 0x00,
	0x61, 0x00,
	0x62, 0x00,
	0x63, 0x00,
	0x64, 0x00,
	0x65, 0x00,
	0x66, 0x00,
	0x67, 0x00,
	0x68, 0x00,
	0x69, 0x00,
	0x6A, 0x00,
	0x6B, 0x00,
	0x6C, 0x00,
	0x6D, 0x00,
	0x6E, 0x00,
	0x6F, 0x00,
	0x70, 0x00,
	0x71, 0x00,
	0x72, 0x00,
	0x73, 0x00,
	0x74, 0x00,
	0x75, 0x00,
	0x76, 0x00,
	0x77, 0x00,
	0x78, 0x00,
	0x79, 0x00,
	0x7A, 0x00,
	0x7B, 0x00,
	0x7C, 0x00,
	0x7D, 0x00,
	0x7E, 0x01,
	0x7F, 0x00,
	0x80, 0x00,
	0x81, 0x00,
	0x82, 0x00,
	0x83, 0x00,
	0x84, 0x00,
	0x85, 0x00,
	0x86, 0x00,
	0x87, 0x00,
	0x88, 0x00,
	0x89, 0x00,
	0x8A, 0x00,
	0x8B, 0xFF,
	0x8C, 0xFE,
	0x8D, 0x00,
	0x8E, 0x00,
	0x8F, 0x00,
	0x90, 0xFF,
	0x91, 0xFE,
	0x92, 0x00,
	0x93, 0x00,
	0x94, 0x00,
	0x95, 0x00,
	0x96, 0x00,
	0x97, 0x00,
	0x98, 0x00,
	0x99, 0x00,
	0x9A, 0x00,
	0x9B, 0x00,
	0x9C, 0x00,
	0x9D, 0x00,
	0x9E, 0x00,
	0x9F, 0x00,
	0xA0, 0x00,
	0xA1, 0x00,
	0xA2, 0x00,
	0xA3, 0x00,
	0xA4, 0x00,
	0xA5, 0x00,
	0xA6, 0x00,
	0xA7, 0x00,
	0xA8, 0x00,
	0xA9, 0x00,
	0xAA, 0x00,
	0xAB, 0x00,
	0xAC, 0x00,
	0xAD, 0x00,
	0xAE, 0x00,
	0xAF, 0x00,
	0xB0, 0x00,
	0xB1, 0x00,
	0xB2, 0x00,
	0xB3, 0xFA,
	0xB4, 0x00,
	0xB5, 0x00,
	0xB6, 0x00,
	0xB7, 0x00,
	0xB8, 0x00,
	0xB9, 0x01,
	0xBA, 0x00,
	0xBB, 0x00,
	0xBC, 0x03,
	0xBD, 0x00,
	0xBE, 0x00,
	0xBF, 0x00,
	0xC0, 0x00,
	0xC1, 0x00,
	0xC2, 0x0B,
	0xC3, 0x0C,
	0xC4, 0x00,
	0xC5, 0x00,
	0xC6, 0x1F,
	0xC7, 0x78,
	0xC8, 0x21,
	0xC9, 0x00,
	0xCA, 0x00,
	0xCB, 0x07,
	0xCC, 0x08,
	0xCD, 0x00,
	0xCE, 0x00,
	0xCF, 0x04,
	0xD0, 0x00,
	0xD1, 0x00,
	0xD2, 0x60,
	0xD3, 0x10,
	0xD4, 0x06,
	0xD5, 0xBE,
	0xD6, 0x39,
	0xD7, 0x27,
	0xD8, 0x00,
	0xD9, 0x00,
	0xDA, 0x00,
	0xDB, 0x00,
	0xDC, 0x00,
	0xDD, 0x00,
	0xDE, 0x00,
	0xDF, 0x00,
	0xE0, 0x00,
	0xE1, 0x00,
	0xE2, 0x00,
	0xE3, 0x00,
	0xE4, 0x00,
	0xE5, 0x00,
	0xE6, 0x00,
	0xE7, 0x00,
	0xE8, 0x00,
	0xE9, 0x00,
	0xEA, 0x00,
	0xEB, 0x00,
	0xEC, 0x00,
	0xED, 0x00,
	0xEE, 0x00,
	0xEF, 0x00,
	0xF0, 0x00,
	0xF1, 0x00,
	0xF2, 0x00,
	0xF3, 0x00,
	0xF4, 0x00,
	0xF5, 0x00,
	0xF6, 0x00,
	0xF7, 0x00,
	0xF8, 0x00,
	0xF9, 0x00,
	0xFA, 0x00,
	0xFB, 0x00,
	0xFC, 0xC0,
	0xFD, 0x00,
	0xFE, 0x28,
#endif


#if (TP2825_25HZ || TP2825_30HZ) //1280X720,30hz,30fps or 25hz 25fps,hu
		0xFF, 0x00, //; Page 0
		0x00, 0x11,
		0x01, 0x7E,
		0x02, 0xCA,	
		
	#if TP2825_25HZ
		0x03, 0x1d,
	#else
		0x03, 0x0C,
	#endif
	
		0x04, 0x00,
		0x05, 0x00,
		0x06, 0x32,
		0x07, 0xC0,
		0x08, 0x00,
		0x09, 0x24,
		0x0A, 0x48,
		0x0B, 0xC0,
		0x0C, 0x53,
		0x0D, 0x10,
		0x0E, 0x00,
		0x0F, 0x00,
		0x10, 0x00,
		0x11, 0x40,
		0x12, 0x40,
		0x13, 0x00,
		0x14, 0x00,
		0x15, 0x13,
		0x16, 0x16,
		0x17, 0x00,
		0x18, 0x19,
		0x19, 0xD0,
		0x1A, 0x25,
		0x1B, 0x00,
		
	#if TP2825_25HZ	
		0x1C, 0x07,
		0x1D, 0xBC,
	#else
		0x1C, 0x06,
		0x1D, 0x72,
	#endif
	
		0x1E, 0x80,
		0x1F, 0x80,
		0x20, 0x60,
		0x21, 0x86,
		0x22, 0x38,
		0x23, 0x3C,
		0x24, 0x56,
		0x25, 0xFF,
		0x26, 0x02,
		0x27, 0x2D,
		0x28, 0x00,
		0x29, 0x48,
		0x2A, 0x30,
		0x2B, 0x70,
		0x2C, 0x0A,
		0x2D, 0x30,
		0x2E, 0x70,
		0x2F, 0x00,
		0x30, 0x48,
		0x31, 0xBB,
		0x32, 0x2E,
		0x33, 0x90,
		0x34, 0x00,
		0x35, 0x25,
		0x36, 0xDC,
		0x37, 0x00,
		
		//0x38, 0x40,
		0x38, 0x4e,
		
		0x39, 0x88,
		0x3A, 0x00,
		0x3B, 0x03,
		0x3C, 0x00,
		
		//0x3D, 0x60,
		//0x3E, 0x00,
		0x3D, 0x40,
		0x3E, 0x80,
	
		0x3F, 0x00,
		0x40, 0x00,
		
		//0x41, 0x00,
		0x41, 0x05,
		
		0x42, 0x00,
		0x43, 0x12,
		0x44, 0x07,
		0x45, 0x49,
		0x46, 0x00,
		0x47, 0x00,
		0x48, 0x00,
		0x49, 0x00,
		0x4A, 0x00,
		0x4B, 0x00,
		0x4C, 0x03,
		0x4D, 0x03,
		0x4E, 0x17,
		0x4F, 0x00,
		0x50, 0x00,
		0x51, 0x00,
		0x52, 0x00,
		0x53, 0x00,
		0x54, 0x00,
		0x55, 0x00,
		0x56, 0x00,
		0x57, 0x00,
		0x58, 0x00,
		0x59, 0x00,
		0x5A, 0x00,
		0x5B, 0x00,
		0x5C, 0x00,
		0x5D, 0x00,
		0x5E, 0x00,
		0x5F, 0x00,
		0x60, 0x00,
		0x61, 0x00,
		0x62, 0x00,
		0x63, 0x00,
		0x64, 0x00,
		0x65, 0x00,
		0x66, 0x00,
		0x67, 0x00,
		0x68, 0x00,
		0x69, 0x00,
		0x6A, 0x00,
		0x6B, 0x00,
		0x6C, 0x00,
		0x6D, 0x00,
		0x6E, 0x00,
		0x6F, 0x00,
		0x70, 0x00,
		0x71, 0x00,
		0x72, 0x00,
		0x73, 0x00,
		0x74, 0x00,
		0x75, 0x00,
		0x76, 0x00,
		0x77, 0x00,
		0x78, 0x00,
		0x79, 0x00,
		0x7A, 0x00,
		0x7B, 0x00,
		0x7C, 0x00,
		0x7D, 0x00,
		0x7E, 0x01,
		0x7F, 0x00,
		0x80, 0x00,
		0x81, 0x00,
		0x82, 0x00,
		0x83, 0x00,
		0x84, 0x00,
		0x85, 0x00,
		0x86, 0x00,
		0x87, 0x00,
		0x88, 0x00,
		0x89, 0x00,
		0x8A, 0x00,
		0x8B, 0xFF,
		0x8C, 0xFF,
		0x8D, 0xFF,
		0x8E, 0xFF,
		0x8F, 0xFF,
		0x90, 0xFF,
		0x91, 0xFF,
		0x92, 0xFF,
		0x93, 0xFF,
		0x94, 0xFF,
		0x95, 0x00,
		0x96, 0x00,
		0x97, 0x00,
		0x98, 0x00,
		0x99, 0x00,
		0x9A, 0x00,
		0x9B, 0x00,
		0x9C, 0x00,
		0x9D, 0x00,
		0x9E, 0x00,
		0x9F, 0x00,
		0xA0, 0x00,
		0xA1, 0x00,
		0xA2, 0x00,
		0xA3, 0x00,
		0xA4, 0x00,
		0xA5, 0x00,
		0xA6, 0x00,
		0xA7, 0x00,
		0xA8, 0x00,
		0xA9, 0x00,
		0xAA, 0x00,
		0xAB, 0x00,
		0xAC, 0x00,
		0xAD, 0x00,
		0xAE, 0x00,
		0xAF, 0x00,
		0xB0, 0x00,
		0xB1, 0x00,
		0xB2, 0x00,
		0xB3, 0xFA,
		0xB4, 0x00,
		0xB5, 0x00,
		0xB6, 0x00,
		0xB7, 0x00,
		0xB8, 0x00,
		0xB9, 0x01,
		0xBA, 0x00,
		0xBB, 0x00,
		0xBC, 0x03,
		0xBD, 0x00,
		0xBE, 0x00,
		0xBF, 0x00,
		0xC0, 0x00,
		0xC1, 0x00,
		0xC2, 0x0B,
		0xC3, 0x0C,
		0xC4, 0x00,
		0xC5, 0x00,
		0xC6, 0x1F,
		0xC7, 0x78,
		0xC8, 0x21,
		0xC9, 0x00,
		0xCA, 0x00,
		0xCB, 0x07,
		0xCC, 0x08,
		0xCD, 0x00,
		0xCE, 0x00,
		0xCF, 0x04,
		0xD0, 0x00,
		0xD1, 0x00,
		0xD2, 0x60,
		0xD3, 0x10,
		0xD4, 0x06,
		0xD5, 0xBE,
		0xD6, 0x39,
		0xD7, 0x27,
		0xD8, 0x00,
		0xD9, 0x00,
		0xDA, 0x00,
		0xDB, 0x00,
		0xDC, 0x00,
		0xDD, 0x00,
		0xDE, 0x00,
		0xDF, 0x00,
		0xE0, 0x00,
		0xE1, 0x00,
		0xE2, 0x00,
		0xE3, 0x00,
		0xE4, 0x00,
		0xE5, 0x00,
		0xE6, 0x00,
		0xE7, 0x00,
		0xE8, 0x00,
		0xE9, 0x00,
		0xEA, 0x00,
		0xEB, 0x00,
		0xEC, 0x00,
		0xED, 0x00,
		0xEE, 0x00,
		0xEF, 0x00,
		0xF0, 0x00,
		0xF1, 0x00,
		0xF2, 0x00,
		0xF3, 0x00,
		0xF4, 0x00,
		0xF5, 0x00,
		0xF6, 0x00,
		0xF7, 0x00,
		0xF8, 0x00,
		0xF9, 0x00,
		0xFA, 0x00,
		0xFB, 0x00,
		0xFC, 0xC0,
		0xFD, 0x00,
		0xFE, 0x28,
#endif

};

#endif

#if TP2825_720X480 //tw9990
static unsigned char tp2825_init_regs[] = 
{
	#if 1//N
	0x00, 0x00,
	0x01, 0x78,
	//0x02, 0xC0,//// MUX0 diff mode
	//0x02, 0x40,//// MUX0
	//0x02, 0x44,//// MUX1

	0x02, 0x48,//// MUX2

	0x03, 0xA0,
	0x04, 0x00,
	0x05, 0x00,
	0x06, 0x00,
	0x07, 0x02,
	0x08, 0x12,
	0x09, 0xF0,
	0x0A, 0x10,
	0x0B, 0xD0,
	0x0C, 0xCC,
	0x0D, 0x74,
	0x0E, 0x11,
	//0x0F, 0x31,

	0x0F, 0x31,

	0x10, 0xF7,
	0x11, 0x64,
	0x12, 0x26,
	0x13, 0x90,
	0x14, 0x90,
	0x15, 0x00,
	0x16, 0x00,
	0x17, 0x32,
	0x18, 0x44,
	0x19, 0x58,
	0x1A, 0x0A,
	0x1B, 0x00,
	0x1C, 0x07,
	0x1D, 0x7F,
	0x1E, 0x08,
	0x1F, 0x00,
	0x20, 0xA0,
	0x21, 0x42,
	0x22, 0xF0,
	0x23, 0xD8,
	0x24, 0xBC,
	0x25, 0xB8,
	0x26, 0x44,
	0x27, 0x2A,
	0x28, 0x00,
	0x29, 0x00,
	0x2A, 0x78,
	0x2B, 0x44,
	0x2C, 0x40,
	0x2D, 0x14,
	0x2E, 0xA5,
	0x2F, 0xE0,
	0x30, 0x00,
	0x31, 0x10,
	0x32, 0xFF,
	0x33, 0x05,
	0x34, 0x1A,
	0x35, 0xA0,
	0x36, 0x00,
	0x37, 0x00,
	0x38, 0x00,
	0x39, 0x00,
	0x3A, 0x00,
	0x3B, 0x00,
	0x3C, 0x00,
	0x3D, 0x00,
	0x3E, 0x00,
	0x3F, 0x00,
	0x40, 0x00,
	0x41, 0x00,
	0x42, 0x00,
	0x43, 0x00,
	0x44, 0x00,
	0x45, 0x00,
	0x46, 0x00,
	0x47, 0x00,
	0x48, 0x00,
	0x49, 0x00,
	0x4A, 0x00,
	0x4B, 0x00,
	0x4C, 0x05,
	0x4D, 0x40,
	0x4E, 0x00,
	0x4F, 0x00,
	0x50, 0xA0,
	0x51, 0x22,
	0x52, 0x31,
	0x53, 0x80,
	0x54, 0x00,
	0x55, 0x00,
	0x56, 0x00,
	0x57, 0x00,
	0x58, 0x00,
	0x59, 0x00,
	0x5A, 0x00,
	0x5B, 0x00,
	0x5C, 0x00,
	0x5D, 0x00,
	0x5E, 0x00,
	0x5F, 0x00,
	0x60, 0x00,
	0x61, 0x00,
	0x62, 0x00,
	0x63, 0x00,
	0x64, 0x00,
	0x65, 0x00,
	0x66, 0x00,
	0x67, 0x00,
	0x68, 0x00,
	0x69, 0x00,
	0x6A, 0x00,
	0x6B, 0x06,
	0x6C, 0x24,
	0x6D, 0x00,
	0x6E, 0x20,
	0x6F, 0x13,	
#else	//P
	0x00, 0x00,
	0x01, 0x78,
	0x02, 0xC0,//// MUX0
	0x03, 0xA0,
	0x04, 0x00,
	0x05, 0x00,
	0x06, 0x00,
	0x07, 0x12,
	0x08, 0x13,
	0x09, 0x20,
	0x0A, 0x0F,
	0x0B, 0xD0,
	0x0C, 0xCC,
	0x0D, 0x74,
	0x0E, 0x11,
	0x0F, 0x31,
	0x10, 0xF7,
	0x11, 0x64,
	0x12, 0x26,
	0x13, 0x90,
	0x14, 0x90,
	0x15, 0x00,
	0x16, 0x00,
	0x17, 0x32,
	0x18, 0x44,
	0x19, 0x58,
	0x1A, 0x0A,
	0x1B, 0x00,
	0x1C, 0x07,
	0x1D, 0x7F,
	0x1E, 0x08,
	0x1F, 0x00,
	0x20, 0xA0,
	0x21, 0x42,
	0x22, 0xF0,
	0x23, 0xD8,
	0x24, 0xBC,
	0x25, 0xB8,
	0x26, 0x44,
	0x27, 0x2A,
	0x28, 0x00,
	0x29, 0x00,
	0x2A, 0x78,
	0x2B, 0x44,
	0x2C, 0x40,
	0x2D, 0x14,
	0x2E, 0xA5,
	0x2F, 0xE0,
	0x30, 0x00,
	0x31, 0x10,
	0x32, 0xFF,
	0x33, 0x05,
	0x34, 0x1A,
	0x35, 0xA0,
	0x36, 0x00,
	0x37, 0x00,
	0x38, 0x00,
	0x39, 0x00,
	0x3A, 0x00,
	0x3B, 0x00,
	0x3C, 0x00,
	0x3D, 0x00,
	0x3E, 0x00,
	0x3F, 0x00,
	0x40, 0x00,
	0x41, 0x00,
	0x42, 0x00,
	0x43, 0x00,
	0x44, 0x00,
	0x45, 0x00,
	0x46, 0x00,
	0x47, 0x00,
	0x48, 0x00,
	0x49, 0x00,
	0x4A, 0x00,
	0x4B, 0x00,
	0x4C, 0x05,
	0x4D, 0x40,
	0x4E, 0x00,
	0x4F, 0x00,
	0x50, 0xA0,
	0x51, 0x22,
	0x52, 0x31,
	0x53, 0x80,
	0x54, 0x00,
	0x55, 0x00,
	0x56, 0x00,
	0x57, 0x00,
	0x58, 0x00,
	0x59, 0x00,
	0x5A, 0x00,
	0x5B, 0x00,
	0x5C, 0x00,
	0x5D, 0x00,
	0x5E, 0x00,
	0x5F, 0x00,
	0x60, 0x00,
	0x61, 0x00,
	0x62, 0x00,
	0x63, 0x00,
	0x64, 0x00,
	0x65, 0x00,
	0x66, 0x00,
	0x67, 0x00,
	0x68, 0x00,
	0x69, 0x00,
	0x6A, 0x00,
	0x6B, 0x06,
	0x6C, 0x24,
	0x6D, 0x00,
	0x6E, 0x20,
	0x6F, 0x13,	
#endif
};
#endif

static int init_device(void)
{
	int i;
	int rev;
	//msleep(10);
	//tp2825_write_reg(0x0F, 0x00);
	for (i = 0; i < sizeof(tp2825_init_regs); i += 2)
	{
		tp2825_write_reg(tp2825_init_regs[i], tp2825_init_regs[i + 1]);
		//rev = tp2825_read(tp2825_init_regs[i]);
		//printk("tp2825 reg=%x w=%x r=%x\n",tp2825_init_regs[i],tp2825_init_regs[i + 1], rev);
	}
	return 0;
}


static int test_device(void)
{
	int i=4;	
	int rev;
	int j;	
#if 0
	for (j = 0; j < 30; j++ )	
	{
		rev = tp2825_read(tp2825_init_regs[i]);
		printk("tp2825 reg=%x w=%x r=%x\n",tp2825_init_regs[i],tp2825_init_regs[i + 1], rev);
		if(tp2825_init_regs[i + 1] == rev)
		{			
			break;
		}
		msleep(200);
	}
#endif
	//for (i = 0; i < sizeof(tp2825_init_regs); i += 2)	
	//for (i = 0; i < 4; i += 2)	
	{
		rev = tp2825_read(tp2825_init_regs[i]);
		printk("tp2825 reg=%x w=%x r=%x\n",tp2825_init_regs[i],tp2825_init_regs[i + 1], rev);		
	}
	return 0;
}

/*!
 * tp2825 I2C probe function
 *
 * @param adapter            struct i2c_adapter *
 * @return  Error code indicating success or failure
 */
static int tp2825_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	struct pinctrl *pinctrl;
	struct device *dev = &client->dev;
	struct v4l2_subdev *sd;
	int retval;
	const char *vmode;
	u8 chip_id;

	printk("lqc:tp2825_probe imx8\n\n");

	
	/* tp2825 pinctrl */
	pinctrl = devm_pinctrl_get_select_default(dev);
	if (IS_ERR(pinctrl)) {
		dev_err(dev, "setup pinctrl failed\n");
		return PTR_ERR(pinctrl);
	}

	/* request power down pin */
	/* ---- no power down gpio on the board ---- */

	/* request reset pin */
	rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
	if (!gpio_is_valid(rst_gpio)) {
		dev_err(dev, "no sensor reset pin available\n");
		return -EINVAL;
	}
	retval = devm_gpio_request_one(dev, rst_gpio, GPIOF_OUT_INIT_LOW,
					"tp2825_reset");

	/* Set initial values for the sensor struct. */
	memset(&tp2825_data, 0, sizeof(tp2825_data));

	retval = of_property_read_u32(dev->of_node, "csi_id",
				&(tp2825_data.csi));
	if (retval) {
		dev_err(dev, "csi_id invalid\n");
		return retval;
	}

	if(of_property_read_string(dev->of_node, "vmode", &vmode))
	{
		dev_err(dev, "camdev error: no vmode config available\n");
		return -ENODEV;
	}

	if(!strcmp(vmode, "ntsc"))
	{
		video_idx = TP2825_NTSC;
	}
	else if(!strcmp(vmode, "pal"))
	{
		video_idx = TP2825_PAL;
	}
	else
	{
		dev_err(dev, "camdev error: unknown vmode %s\n", vmode);
		return -ENODEV;
	}

	pr_info("camdev: vmode is %s\n", (video_idx == TP2825_NTSC) ? "NTSC" : "PAL");

	tp2825_data.i2c_client = client;

	tp2825_data.pix.pixelformat = V4L2_PIX_FMT_VYUY;  /* YUV422 */
	tp2825_data.pix.width = video_fmts[video_idx].raw_width;
	tp2825_data.pix.height = video_fmts[video_idx].raw_height;
	tp2825_data.streamcap.capturemode = 0;

#if TP2825_50HZ	
	tp2825_data.streamcap.timeperframe.denominator = 50;
#endif

#if TP2825_60HZ	
	tp2825_data.streamcap.timeperframe.denominator = 60;
#endif

#if TP2825_30HZ	
	tp2825_data.streamcap.timeperframe.denominator = 30;
#endif

#if TP2825_25HZ	
	tp2825_data.streamcap.timeperframe.denominator = 25;
#endif

#if TP2825_720X480
	tp2825_data.streamcap.timeperframe.denominator = (video_idx == TP2825_NTSC) ? 30 : 25;
#endif

	tp2825_data.streamcap.timeperframe.numerator = 1;
	tp2825_reset();

	chip_id = tp2825_read(TP2825_IDENT);
	if (retval < 0) {
		pr_warning("tp2825 is not found\n");
		return -ENODEV;
	}
	pr_info("%s: TP2825_IDENT = 0x%x\n", __func__, chip_id);

	init_device();

	sd = &tp2825_data.subdev;
	v4l2_i2c_subdev_init(sd, client, &tp2825_ops);

	msleep(10);
	test_device();
	
	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
	tp2825_data.pad.flags = MEDIA_PAD_FL_SOURCE;

	retval = media_entity_pads_init(&sd->entity, 1, &tp2825_data.pad);
	sd->entity.ops = &tp2825_sd_media_ops;

	retval = v4l2_async_register_subdev(sd);
	if (retval < 0) {
		dev_err(&client->dev,
					"%s--Async register failed, ret=%d\n", __func__, retval);
		media_entity_cleanup(&sd->entity);
	}
	msleep(10);
	test_device();
	
	pr_info("%s camera tp2825, is found\n", __func__);
	return retval;
}

/*!
 * tp2825 I2C detach function
 *
 * @param client            struct i2c_client *
 * @return  Error code indicating success or failure
 */
static int tp2825_remove(struct i2c_client *client)
{
	struct v4l2_subdev *sd = i2c_get_clientdata(client);

	v4l2_async_unregister_subdev(sd);

	return 0;
}


module_i2c_driver(tp2825_i2c_driver);

MODULE_AUTHOR("Freescale Semiconductor, Inc.");
MODULE_DESCRIPTION("TP2825 Camera Driver");
MODULE_LICENSE("GPL");
MODULE_VERSION("3.0");
MODULE_ALIAS("CSI");
